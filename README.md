<!-- Please do not edit this file directly. Update README.mld instead. -->

# Parseff

Parseff is a direct-style parser combinator library for OCaml 5. Write parsers as plain functions with typed errors, streaming input, and zero-copy APIs.

[Documentation](https://davesnx.github.io/parseff/)


## Installation

```bash
$ opam install parseff -y
```

## Example

```ocaml
let number () =
  let digits = Parseff.many1 Parseff.digit () in
  let n = List.fold_left (fun acc d -> (acc * 10) + d) 0 digits in
  if n >= 0 && n <= 255 then n
  else Parseff.error (`Out_of_range n)

let ip_address () =
  let a = number () in
  let _ = Parseff.char '.' in
  let b = number () in
  let _ = Parseff.char '.' in
  let c = number () in
  let _ = Parseff.char '.' in
  let d = number () in
  Parseff.end_of_input ();
  (a, b, c, d)

let () =
  match Parseff.parse "192.168.1.1" ip_address with
  | Ok ((a, b, c, d)) ->
      Printf.printf "Parsed: %d.%d.%d.%d\n" a b c d
  | Error { pos; error = `Out_of_range n } ->
      Printf.printf "Error at %d: %d out of range (0-255)\n" pos n
  | Error { pos; error = `Unexpected_end_of_input } ->
      Printf.printf "Error at %d: unexpected end of input\n" pos
  | Error { pos; error = `Expected msg } ->
      Printf.printf "Error at %d: %s\n" pos msg
```

## Features

- Build parsers with direct-style and `Parseff` combinators
- **No** monadic operators (`>>=`, `>>|`, `*>`), **neither** binding operators (`let*`, `let+`, `and+`)
- Automatic backtracking with `Parseff.or_`
- Typed domain errors via polymorphic variants, raise with `Parseff.error`. Parseff also adds `` `Expected of string`` and `` `Unexpected_end_of_input`` as possible parsing failures
- **Streaming input** with `Source.of_string`, `Source.of_channel`, `Source.of_function` -- same parser code works with both `parse` and `parse_source`
- **Performance** -- 1.6x to 4.3x faster than Angstrom on JSON benchmarks, with 3x less memory
- Zero-copy span APIs for low-allocation parsing (`Parseff.take_while_span`, `Parseff.sep_by_take_span`, `Parseff.fused_sep_take`, `Parseff.skip_while_then_char`)
- Fused operations for hot paths (`Parseff.sep_by_take`, `Parseff.skip_while_then_char`)
- Domain-safe: each `parse` / `parse_source` call is self-contained with no global mutable state, so independent parses can run in parallel across OCaml 5 domains
- Minimal dependency footprint: only `re` for regex support

## Thread Safety

Parseff is safe to use from multiple OCaml 5 domains concurrently. All mutable state (the parser position, the internal buffer, the recursion depth counter) is created locally inside each `parse` or `parse_source` call and is never shared. There is no global mutable state in the library.

This means you can run independent parses in parallel without synchronization:

```ocaml
let results =
  List.init num_workers (fun i ->
    Domain.spawn (fun () ->
      Parseff.parse inputs.(i) my_parser))
  |> List.map Domain.join
```
The only constraint is that a single `Source.t` value must not be shared across domains, since it contains mutable read state. Create a separate source per domain.


## Comparison

| Feature | Parseff | Angstrom | MParser | Opal |
| --- | --- | --- | --- | --- |
| API | Direct-style \+ Composition | Declarative \+ Monadic | Monadic \+ | Monadic |
| Backtracking by default | Yes ✅ | Yes ✅ | No ❌ | No ❌ |
| Unbounded lookahead | Yes ✅ | Yes ✅ | Yes ✅ | No ❌ |
| Custom error types | Yes ✅ | No ❌ | No ❌ | No ❌ |
| Zero-copy API | Yes ✅ | Yes ✅ | No ❌ | No ❌ |
| Streaming/incremental input | Yes ✅ | Yes ✅ | No ❌ | No ❌ |
| Requires OCaml 5+ | Yes ✅ | No ❌ | No ❌ | No ❌ |

## Performance

Benchmarked on a JSON parser over a 10-element numeric array for 100,000 iterations:

- Parseff (zero-copy spans): ~4,940,000 parses/sec (4.3x faster than Angstrom)
- Parseff (fair comparison): ~1,930,000 parses/sec (1.6x faster than Angstrom)
- Angstrom: ~1,150,000 parses/sec (baseline)
Memory: Parseff 197 MB vs Angstrom 584 MB (3x less).

See [bench/bench\_vs\_angstrom.ml](./bench/bench_vs_angstrom.ml) for the benchmark source.


## References

- [A Typed, Algebraic Approach to Parsing](https://www.cl.cam.ac.uk/~jdy22/papers/a-typed-algebraic-approach-to-parsing.pdf) by Krishnaswami & Yallop (PLDI '19)
- [Algebraic Effects and Effect Handlers](https://okmij.org/ftp/Computation/variables-effects.html) by Kiselyov, O. et al.
- [yieldparser](https://github.com/JavaScriptRegenerated/yieldparser): JavaScript generator-based parsing

## Contributing

- Open an issue to discuss proposed changes
- Write tests for new features
- Run `make fmt` before submitting
- Ensure all tests pass with `make test`

## License

MIT. See [LICENSE](./LICENSE) for details.
